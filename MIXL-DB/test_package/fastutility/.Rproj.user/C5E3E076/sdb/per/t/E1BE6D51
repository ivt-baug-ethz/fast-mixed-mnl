{
    "collab_server" : "",
    "contents" : "#data restricted\n#mlhs - intra\nlist.of.packages <- c(\"maxLik\",\"data.table\",\"sandwich\",\"numDeriv\",\"randtoolbox\",\"parallel\",\"doParallel\",\"Rcpp\",\"fastutility\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\n#install\nif(length(new.packages)) install.packages(new.packages)\n#load\n(lapply(list.of.packages, require, character.only = TRUE))\n\n\n#Adjust the path, which contains the folders: Scripts, Results\nreadFunctions<-function(){\n  \n  #Put in R script with path<<-\"-pathtoFMOD-\" in C:/users/-yourusername-\n  if(file.exists(paste0(\"C:/users/\",Sys.info()[\"user\"],\"/pathFMOD.R\"))){\n    \n    source(paste0(\"C:/users/\",Sys.info()[\"user\"],\"/pathFMOD.R\"))\n    \n    \n  }else if(file.exists(paste0(\"/home/fmod/pathFMOD.R\"))){\n    source(paste0(\"/home/fmod/pathFMOD.R\"))\n  }else if(file.exists(paste0(\"/nas/beckerfe/pathFMOD.R\"))){\n    source(paste0(\"/nas/\",Sys.info()[\"user\"],\"/pathFMOD.R\"))\n    \n  }else if(file.exists(paste0(\"/cluster/home/beckerfe/pathFMOD.R\"))){\n    source(paste0(\"/cluster/home/beckerfe/pathFMOD.R\"))\n  }\n  \n  \n  source(paste(path,\"Scripts/Mainfiles/Functions.R\",sep=\"\"))\n  source(paste(path,\"MSL/scripts/Mainfiles/function_input.R\",sep=\"\"))\n  \n}\n\n\nrm(list=setdiff(ls(), \"readFunctions\"))\nreadFunctions()\n\npath <- paste0(path,\"MSL/\")\n\ncontrol<-list()\ncontrol$tol=10^-8\nprint(paste0(\"Convergence criterion = \",control$tol))\nNdraws=10    # set number of draws to use per person and per parameter\n\nprint(paste0(\"Inter draws=\",Ndraws))\n Nintradraws=10# set number of draws to use per choice sit and per parameter\nprint(paste0(\"Intra draws =\",Nintradraws))\n\nstartiter=10\n\nset.seed(42)\n#####################################################################\n#####################################################################\n# MODEL NAME                                                        #\n#####################################################################\n#####################################################################\n\nmodelname=\"Ex_IE_onIELow_Grapes_500_verypars_500draws\" # this is used for saving the model results, make sure to use a new name for every model\n\nif(!dir.exists(paste0(path,\"output/\",modelname))){\n  dir.create(paste0(path,\"output/\",modelname))\n  \n}\noutputpath <- paste0(path,\"output/\",modelname,\"/\")\n\n#####################################################################\n#####################################################################\n# OVERALL SETTINGS                                                  #\n#####################################################################\n#####################################################################\n\npaneldata=1 # set to 0 for cross-sectional data, or cross-sectional estimation of a panel dataset\nmixing=1    # set to 1 for models that include random parameters\nfunctionality=1 # set to 1 for estimation, 2 for prediction and 3 to output unconditional and conditional draws from Mixed Logit\nintramixing=1# set to 1 for models that include intra-respondent heterogeneity (only works with mixing =1)\nstartingvaluesloop=1 # set to 1 to use starting values loop before estimation\n\nparallelcomputing = 0  # set to 1 to use multiple cores for estimation\n# set number of cores for parallel computing:\n\nprint(paste0(\"Parallel is \",parallelcomputing))\n\nif (parallelcomputing==1) {\n  kernel <-   detectCores(all.tests = FALSE, logical = TRUE)\n  kernel <- min(kernel,16)\n  #parallelCluster <- makeCluster(kernel, type = \"FORK\")\n  registerDoParallel(cores=kernel)\n} else kernel <- 1\n\n#####################################################################\n#####################################################################\n# DATA INPUT                                                        #\n#####################################################################\n#####################################################################\n\n# define name of data file - note that observations for the  same individual should be grouped together\n\n\nowndata= getGrapes(dataPath=paste0(path,\"data/VeryParsimonious/grapes_IELow_500_verypars.dat\"),scaling = 0) \n#data <- data[1:1000,]\n# use for tab separated files\n#data=read.table(datafilename,header=T) # use for tab separated files\n\n\n# turn into data table (for more computationally efficient processing)\nowndata=data.table(owndata)\n\nowndata[,c(which(colnames(owndata)==\"U_1\"):(which(colnames(owndata)==\"U_1\")+11)):=NULL]\n\n# set number of alternatives in model\nnumber_of_alts=4\n\n# calculate LL(0) - this basic calculation assumes that availabilities are all 1\nLL0=nrow(owndata)*log(1/number_of_alts)\n\n# if e.g. availability is given in columns avail1,avail2,avail3 in the data, \n#then use avail=data[, .SD, .SDcols=c(\"avail1\",\"avail2\",\"avail3\")]\n# and LL0=sum(log(1/rowSums(avail)))\n\n# set ID variable - leave unchanged if variable in data is called ID already\nowndata[,ID:=ID]\nowndata[,CHOICE:=Choice]\nowndata[,CT:=m]\n# determine number of individuals in the data\nN=length(unique(owndata[,ID]))\n\n# determine number of choice tasks in the data\nchoicetasks=nrow(owndata)\n\n# create a running index of choice tasks for each person\nowndata[,running_task:=0]\nk=1\ni=1\nwhile(i<(N+1))\n{\n  owndata[(k:(k+sum(owndata[,ID==ID[k]])-1)),running_task:=as.double(1:sum(owndata[,ID==ID[k]]))]  \n  k=k+sum(owndata[,ID==ID[k]])\n  i=i+1\n}\n\n# the following line replaces the current set of IDs if using cross-sectional estimation\nif(paneldata==0){\n  owndata[,ID:=ID+running_task/100]\n  N=length(unique(owndata[,ID]))\n  # now set the running task to 1 for every row to recognise that we're treating the data as cross-sectional\n  owndata[,running_task:=1]\n} \n\n#####################################################################\n#####################################################################\n# CREATE DRAWS FOR RANDOM PARAMETERS                                #\n#####################################################################\n#####################################################################\n\n#Use different types of draws for the inter and the intra\n#See example below\n\n\n\nnrobs = nrow(owndata)\nlengthinter = nrobs*Ndraws\n\n\ngen<-function(id,ctid){\n  rep(c((1+Ndraws*(id-1)):(Ndraws*id)),ctid)\n}\nif(mixing==1)\n{\n  dimensions=1    # define number of random terms in the model\n  draws=as.matrix(halton(Ndraws*N,dimensions,normal = T))\n  #draws <- matrix(0,ncol=dimensions,nrow=Ndraws*N)\n  \n  colnames(draws)=c(\"B_L\")\n  normaldraws=c(\"draws1\")\n  draws <- data.table(draws)\n  print(\"Inter draws generated\")\n  drawsrep <- unlist(mapply(id=unique(owndata$ID),FUN = gen,ctid=as.numeric(table(owndata$ID)),SIMPLIFY = F))\n  \n}\n\n\nNintra= nrow(owndata)\n\nif(intramixing==1)\n{\n  intradimensions=1    # define number of random intra terms in the model\n  #draws_intra=as.matrix(mlhs(Nintradraws,intradimensions,Nintra))\n  draws_intra=as.matrix(halton(Nintradraws*nrobs,intradimensions,normal = T))\n  #draws_intra <- matrix(0,ncol=intradimensions,nrow=Nintradraws*nrobs)\n  \n  colnames(draws_intra)=c(\"B_L\")\n  intranormaldraws=c(\"draws2intra\")\n  draws_intra <- data.table(draws_intra)\n  \n  print(\"Intra draws generated\")\n}\n\n\n\nprint(\"Draws rep generated\")\n#####################################################################\n#####################################################################\n# DEFINE MODEL PARAMETERS                                           #\n#####################################################################\n#####################################################################\n\n# set names for parameters\nparnames=c(\"B_L\",\"B_Cost\")\nparnames <- c(parnames,paste0(parnames[c(1)],\"_sd_inter\"))\nparnames <- c(parnames,paste0(c(\"B_L\"),\"_sd_intra\"))\n\n# set starting values\nstartvalues=rep(0,12)\nstartvalues = c(0,0,0,0)\n\nstartvalues=c(2.5142401,-0.5058089,-1.0212159,0.4278354) \n\n# convert the above into a beta vector with names\nbeta=startvalues\nnames(beta)=parnames\n\n# OPTIONAL: set fixed parameters (leave empty if none, i.e. fixedparams=c(), otherwise e.g. fixedparams=c(\"beta1\"))\nfixedparams=c()\n\n# set limits for starting values if using random starting values\nif(startingvaluesloop==1)\n{   \n  # these will need fine tuning depending on the model, etc\n  lowerlimits=startvalues-0.1\n  upperlimits=startvalues+0.1\n  \n  # constrain fixed parameters to starting values\n  names(upperlimits)=names(beta)\n  names(lowerlimits)=names(beta)\n  upperlimits[fixedparams]=beta[fixedparams]\n  lowerlimits[fixedparams]=beta[fixedparams]\n  \n  # set iterations to use in starting values loop\n  startingiterations=startiter\n}\n\nif (parallelcomputing==1) {\n  \n  splitid <- rep(1:kernel,each=(N%/%kernel))\n  splitid[length(splitid):N] <- kernel\n  \n  id <- c(1:N)\n  splitter <- data.frame(id,splitid)\n  owndata <- merge(owndata, splitter, by.x = \"ID\", by.y = \"id\", all = TRUE)\n  \n  data_list <- split(owndata,f=owndata$splitid)\n  \n  nrobs_list <- list()\n  \n  for(i in 1:kernel){\n    nrobs_list[[i]] <- sum(owndata$splitid==i)\n    \n  }\n  if (mixing==1) \n  {\n    \n    assignment <- as.data.frame(cbind(drawnr=drawsrep,splitid=owndata$splitid[rep(1:nrobs,each=Ndraws)]))\n    assignmentnotdupl <- assignment[!duplicated(assignment), ]\n    \n    \n    draws_list <- split(draws,f=assignmentnotdupl$splitid)\n    \n    \n    drawsrep_list <- list()\n    lengthinter_list = list()\n    \n    for(i in 1:kernel){\n      drawsrep_list[[i]] <- assignment$drawnr[assignment$splitid==i]\n      drawsrep_list[[i]] <- drawsrep_list[[i]]-min(drawsrep_list[[i]])+1\n      \n      lengthinter_list[[i]]=  nrobs_list[[i]]*Ndraws\n    }\n    \n    \n  }\n  #the same for intra\n  if(intramixing==1){\t\t\t\t \n    \n    \n    #assignment_intra <- as.data.frame(cbind(drawnr=drawsrepintra,splitid=data$splitid[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]))\n    \n    drawsrepintra_list <- list()\n    drawsrepintra_index<-c()\n    for(i in 1:kernel){\n      print(i)\n      drawsrepintra_list[[i]]<-unlist(lapply(c(1:nrow(data_list[[i]])),FUN=function(X)rep((1+Nintradraws*(X-1)):(Nintradraws*X),Ndraws)))\n      if(length(drawsrepintra_list[[i]])==length(drawsrepintra_list[[1]])){\n        if(all.equal(drawsrepintra_list[[i]],drawsrepintra_list[[1]]) && i!=1){\n          drawsrepintra_list[[i]]<-NULL\n          drawsrepintra_index[i] <-1\n        }else{\n          drawsrepintra_index[i] <-i\n          \n        }\n      }\n      else{\n        drawsrepintra_index[i] <-i\n        \n      }\n    }\n    \n    #every choice situation times intra draws\n    draws_intra_list <- split(draws_intra,f=owndata$splitid[rep(1:nrobs,each=Nintradraws)])\n    \n    \n    \n    # drawsrepintra_list <- list()\n    # for(i in 1:kernel){\n    #   drawsrepintra_list[[i]] <- assignment_intra$drawnr[assignment_intra$splitid==i]\n    #   drawsrepintra_list[[i]] <- drawsrepintra_list[[i]]-min(drawsrepintra_list[[i]])+1\n    # }\n    \n    \n    print(\"Data splitting for parallelization finished\")\n  }  \n  \n  \n}else{\n  if(intramixing==1){\n    drawsrepintra <- unlist(lapply(c(1:nrobs),FUN=function(X)rep((1+Nintradraws*(X-1)):(Nintradraws*X),Ndraws)))\n    #suppressWarnings(rm(list=c(\"drawsrepintra\",\"drawsrep\",\"assignment_intra\",\"assignment\",\"assignementnotdupl\",\"assignment_intra_notdupl\",\"draws\",\"draws_intra\",\"splitid\")))\n    \n    \n  }\n  \n} #%parallelcomputing==1%\n\n\n\n\n#test<-cbind(ID=data$ID[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)],CT=data$CT[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)],Inter=drawsrep[rep(1:lengthinter,each=Nintradraws)],Intra=drawsrepintra)\n#write.csv(x = test,file=paste0(path,\"Understand_5.csv\"))\n\n\ncalc_utilities_intra_pars<-function(beta1,customdata,drawsrep,drawsrepintra,Ndraws,Nintradraws,lengthinter,draws,draws_intra,nrobs){\n  \n  \n  utilities <- data.table(U1 = (\n    -customdata$P_1[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)] + \n      (beta1$B_L + beta1$B_L_sd_inter * draws[drawsrep,get(\"B_L\")][rep(1:lengthinter,each=Nintradraws)] + beta1$B_L_sd_intra * draws_intra[drawsrepintra,get(\"B_L\")]) * customdata$L_1[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]\n  )/exp(beta1$B_Cost))\n  \n  utilities[,U2:= (\n    -customdata$P_2[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)] + \n      (beta1$B_L + beta1$B_L_sd_inter * draws[drawsrep,get(\"B_L\")][rep(1:lengthinter,each=Nintradraws)] + beta1$B_L_sd_intra * draws_intra[drawsrepintra,get(\"B_L\")]) * customdata$L_2[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]\n  )/exp(beta1$B_Cost)]\n  \n  \n  utilities[,U3:=(\n    -customdata$P_3[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)] + \n      (beta1$B_L + beta1$B_L_sd_inter * draws[drawsrep,get(\"B_L\")][rep(1:lengthinter,each=Nintradraws)] + beta1$B_L_sd_intra * draws_intra[drawsrepintra,get(\"B_L\")]) * customdata$L_3[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]\n  )/exp(beta1$B_Cost)]\n  \n  utilities[,U4:=0]\n  \n  \n  \n  print(\"utilities ok\")\n  return(utilities)\n}\n\n#still not working correctly!!\n\n\n# \n# cppFunction(\"\n#             NumericVector exfun(NumericMatrix customdata,NumericVector choice, IntegerVector drawsrep,IntegerVector drawsrepintra,double Cost, double B_L, double B_L_sd_inter,double B_L_sd_intra, NumericMatrix draws, NumericMatrix draws_intra, int Ndraws, int Nintradraws){\n#             \n#             \n#             //std::vector<double> utilities(4);\n#             NumericVector utilities(4);\n#             //std::fill(utilities.begin(), utilities.end(), 0);\n#             \n#             \n#             int fulllength = customdata.nrow()*Ndraws*Nintradraws;\n#             NumericVector P(fulllength/Nintradraws) ;\n#             int data_index = 0;\n#             \n#             int totaldraws = Ndraws * Nintradraws;\n#             //check!!!!!!!\n#             double coeff=0;\n#             double ptemp =0;\n#             \n#             for (int i=0; i<fulllength; i++) {\n#             \n#             data_index = i / totaldraws; // 0 index\n#             coeff = B_L+ B_L_sd_inter * draws((drawsrep[(i/Nintradraws)]-1),0) + B_L_sd_intra * draws_intra((drawsrepintra[i]-1),0);\n#             \n#             \n#             \n#             \n#             \n#             //Rcpp::Rcout << i << \\\"\\t\\\" << draws((drawsrep[(i/Nintradraws)]-1),0)  << \\\"\\t\\\"  << drawsrepintra[i]-1 << \\\"\\t\\\" << draws_intra((drawsrepintra[i]-1),0) << std::endl;\n#             \n#             \n#             \n#             //double coeff=i/Nintradraws;\n#             //int data_index  =      datareplicate[i];\n#             utilities[0]=  (-customdata(data_index,0) + coeff * customdata(data_index,3))/exp(Cost);\n#             utilities[1]=  (-customdata(data_index,1) + coeff * customdata(data_index,4))/exp(Cost);\n#             utilities[2]=  (-customdata(data_index,2) + coeff * customdata(data_index,5))/exp(Cost);\n#             utilities[3]=0;\n#             \n#             /*if(i%1000==0){\n#             Rcpp::Rcout << i << \\\"\\t\\\" << utilities[0] << \\\"\\t\\\"  << utilities[1] << \\\"\\t\\\" << utilities[2] << utilities[3] <<  std::endl;\n#             }*/\n#             \n#             double maxim = max(utilities);\n#             double minim = min(utilities);\n#             \n#             \n#             double censor = (maxim + minim)/2;\n#             \n#             /*if(i%1000==0){\n#             Rcpp::Rcout << i << \\\"\\t\\\" << maxim << \\\"\\t\\\"  << minim  << \\\"\\t\\\"  << censor << std::endl;\n#             }*/\n#             \n#             utilities[0]=  exp(utilities[0]-censor);\n#             utilities[1]=  exp(utilities[1]-censor);\n#             utilities[2]=  exp(utilities[2]-censor);\n#             utilities[3]=  exp(utilities[3]-censor);\n#             \n#             ptemp = ptemp + (utilities[choice[data_index]]/(utilities[0]+utilities[1]+utilities[2]+utilities[3]))/Nintradraws;\n#             if(i>0 && i%(Nintradraws-1)==0){\n#             P[i/Nintradraws] = ptemp;\n#             ptemp=0;\n#             }\n#             \n#             //std::accumulate(utilities.begin(), utilities.end(), 0);\n#             //std::accumulate(utilities.begin(), utilities.end(), 0);\n#             //utilities[choice[data_index]]//\n#             }\n#             \n#             \n#             return P;\n#             \n#             }\")\n\n\n\n\n#system.time(util1 <- calc_utilities_intra_pars_6(beta1,customdata,drawsrep,drawsrepintra,Ndraws,Nintradraws,lengthinter,draws,draws_intra,nrobs))\n\n\n\n#system.time( replicate(5, exfun(customdata = customdata1, drawsrep = drawsrep, drawsrepintra = drawsrepintra,Cost = Cost,B_L = beta1$B_L,B_L_sd_inter = beta1$B_L_sd_inter,B_L_sd_intra = beta1$B_L_sd_intra,draws = as.matrix(draws),draws_intra = as.matrix(draws_intra))))\n\n\n\n\n\nherzstueck=function(customdata,draws=NULL,drawsrep=NULL,draws_intra=NULL,drawsrepintra=NULL,lengthinter=NULL,nrobs=NULL,beta1=NULL,Ndraws=NULL,Nintradraws=NULL,functionality=NULL,mixing=NULL,intramixing=NULL){\n  \n  customdata1 <- as.matrix(customdata[,c(3,4,5,15,16,17,49)])\n  \n  choice=(customdata1[,7]-1)\n  draws=as.matrix(draws)\n  draws_intra=as.matrix(draws_intra)\n  start <- Sys.time()\n  a<-  exfun(customdata = customdata1, choice=choice,drawsrep = drawsrep, drawsrepintra = drawsrepintra,Cost = beta1$B_Cost,B_L = beta1$B_L,B_L_sd_inter = beta1$B_L_sd_inter,B_L_sd_intra = beta1$B_L_sd_intra,draws = draws,draws_intra = draws_intra,Ndraws = Ndraws,Nintradraws = Nintradraws)\n  print(paste0(\"C++ \",difftime(time1 = Sys.time(),time2 = start,units = \"secs\")))\n  utilities = data.table(P=a,ID=customdata$ID[rep(1:nrobs,each=Ndraws)],draws_index = drawsrep)\n  \n  \n  #colnames(utilities)<-paste0(\"U\",c(1:4))\n  \n  \n  L = utilities[, .(L = (prod(P))), by = \"ID,draws_index\"]\n  \n  # then average across draws and take the log for simulated log-likelihood \n  LL <- L[, .(out_LL = log(mean(L))), by = ID][[\"out_LL\"]]\n\n  return(LL)\n}\n\n\nherzstueck_1 = function(customdata,draws=NULL,drawsrep=NULL,draws_intra=NULL,drawsrepintra=NULL,lengthinter=NULL,nrobs=NULL,beta1=NULL,Ndraws=NULL,Nintradraws=NULL,functionality=NULL,mixing=NULL,intramixing=NULL){\n  \n  # define utility functions\n  \n  #-----------------------Utilities-------------------------------------\n  \n  #utilities<-as.data.table(calc_utilities_intra_pars_6(beta1,customdata,drawsrep,drawsrepintra,Ndraws,Nintradraws,lengthinter,draws,draws_intra,nrobs))\n  \n  customdata1 <- as.matrix(customdata[,c(3,4,5,15,16,17,49)])\n  \n  \n  #system.time(a<-exfun(customdata = as.matrix(customdata1), choice=(customdata1[,7]-1),drawsrep = drawsrep, drawsrepintra = drawsrepintra,Cost = beta1$B_Cost,B_L = beta1$B_L,B_L_sd_inter = beta1$B_L_sd_inter,B_L_sd_intra = beta1$B_L_sd_intra,draws = as.matrix(draws),draws_intra = as.matrix(draws_intra),Ndraws = Ndraws,Nintradraws = Nintradraws))\n  \n\n  #-----------------------Utility processing and Probabilities-----------------\n  utilities[,Umax:=do.call(pmax,.SD),.SDcols=c(\"U1\",\"U2\",\"U3\",\"U4\")]\n  utilities[,Umin:=do.call(pmin,.SD),.SDcols=c(\"U1\",\"U2\",\"U3\",\"U4\")]\n  utilities[,Ucensor:=(Umax+Umin)/2]\n  \n  utilities[,U1:=U1-Ucensor]\n  utilities[,U2:=U2-Ucensor]\n  utilities[,U3:=U3-Ucensor]\n  utilities[,U4:=U4-Ucensor]\n  \n  \n  # exponentiate utilities\n  utilities[,eU1:=exp(U1)]\n  utilities[,eU2:=exp(U2)]\n  utilities[,eU3:=exp(U3)]\n  utilities[,eU4:=exp(U4)]\n  \n  #delete Ux, Umax, Umin\n  \n  utilities[,c(\"U1\",\"U2\",\"U3\",\"U4\",\"Umax\",\"Umin\",\"Ucensor\"):=NULL]\n  \n  if(mixing ==1 && intramixing ==0){\n    utilities[,CHOICE:=customdata$CHOICE[rep(1:nrobs,each=Ndraws)]]\n    utilities[,ID:=customdata$ID[rep(1:nrobs,each=Ndraws)]]\n    utilities[,running_task:=customdata$running_task[rep(1:nrobs,each=Ndraws)]]\n    utilities[,draws_index := drawsrep] \n  }\n  if(mixing ==1 && intramixing ==1){\n    utilities[,CHOICE:=customdata$CHOICE[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]]\n    utilities[,ID:=customdata$ID[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]]\n    utilities[,running_task:=customdata$running_task[rep(1:nrobs,each=Ndraws)][rep(1:lengthinter,each=Nintradraws)]]\n    utilities[,draws_intra_index := drawsrepintra] \n  }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n  \n  # calculate probability for chosen alternative for each observation (remember to take availabilities into account here if needed) \n  utilities[,P:=((CHOICE==1)*eU1+(CHOICE==2)*eU2+(CHOICE==3)*eU3+(CHOICE==4)*eU4)/(eU1+eU2+eU3+eU4)]\n  \n  print(\"Ut processing ok\")\n  \n  #----------------------For different functionalities----------------------------\n  \n  if(functionality==2)\n  {\n    # for predictions, we need probabilities for all alternatives, not just the chosen one, again, remember availabilities if needed\n    utilities[,P1:=eU1/(eU1+eU2)]  \n    utilities[,P2:=eU2/(eU1+eU2)]     \n    \n    # copy part of the overall data table into a new datatable - ID, task, chosen alternative, probs and prob of chosen\n    probs_out=utilities[, .SD, .SDcols=c(\"ID\",\"running_task\",\"CHOICE\",\"P1\",\"P2\",\"P\")]\n    \n    # take mean across draws (only applies with mixing when multiple copies of same ID-running_task rows exist)\n    probs_out=probs_out[,lapply(.SD, mean, na.rm=TRUE),by=.(ID,running_task)]  \n  }\n  \n  #####################################################################\n  # subsection required only in estimation                            #\n  #####################################################################\n  \n  if(functionality==1)\n  {\n    # compute log-likelihood, different approach with and without mixing\n    if(mixing==0)\n    {\n      # take product across choices for the same person (likelihood)\n      # then take the log for log-likelihood \n      LL <- utilities[, .(out_LL = log(prod(P))), by = ID][[\"out_LL\"]]\n    }\n    else\n    {\n      \n      if (intramixing==0)\n        \n      {\n        # take product across choices for the same person and the same draw\n        L = utilities[, .(L = (prod(P))), by = \"ID,draws_index\"]\n        \n        # then average across draws and take the log for simulated log-likelihood \n        LL <- L[, .(out_LL = log(mean(L))), by = ID][[\"out_LL\"]]\n      }\n      else\n      {\n        \n        #draws_index of individual draws\n        #Check\n        utilities[,draws_index:= drawsrep[rep(1:lengthinter,each=Nintradraws)]]\n        utilities[,CT:=utilities$running_task]\n        \n        #mean over intra\n        L1 = utilities[, .(P = mean(P)),by = \"ID,CT,draws_index\"]\n        #prod over CT\n        L2 = L1[, .(L = prod((P))),by = \"ID,draws_index\"]\n        LL <- L2[, .(out_LL = log(mean(L))), by = ID][[\"out_LL\"]]\n        \n      }\n    }\n  }\n  \n  rm(utilities)\n  \n  return(LL)\n}\n\n#####################################################################\n#####################################################################\n# DEFINE MODEL STRUCTURE AND LIKELIHOOD FUNCTION                    #\n#####################################################################\n#####################################################################\nloglike=function(beta)\n{\n  print(beta)\n  start.time<-Sys.time()\n  \n  # needed to be able to refer to parameters by name\n  beta1=as.list(beta)\n  \n  # define random coefficients\n  \n  #sdcens captures inter respondent heterogeneity\n  #sdicens capture intra respondent heterogeneity\n  \n  \n  \n  \n  if (parallelcomputing==1) {\n    \n    data_outlist <-\n      foreach(i = 1:kernel,.packages = c('data.table',\"Rcpp\",\"fastutility\") ,.export = c(\"herzstueck\",\"data_list\",\"draws_list\",\"drawsrep_list\",\"draws_intra_list\",\"drawsrepintra_list\",\"lengthinter_list\",\"nrobs_list\",\"beta1\",\"Ndraws\",\"Nintradraws\",\"functionality\",\"mixing\",\"intramixing\",\"drawsrepintra_index\")) %dopar% {\n        \n        # customdata = data_list[[i]]\n        # draws = draws_list[[i]]\n        # drawsrep=drawsrep_list[[i]]\n        # draws_intra = draws_intra_list[[i]]\n        # drawsrepintra=drawsrepintra_list[[drawsrepintra_index[i]]]\n        # lengthinter = lengthinter_list[[i]]\n        # nrobs=nrobs_list[[i]]\n        \n        if(intramixing==1){\n          # draws_intra = draws_intra_list[[i]]\n          # drawsrepintra=drawsrepintra_list[[i]]\n          \n          #be aware of drawsrepintra_index!!!\n          LL <-  herzstueck(customdata = data_list[[i]],draws = draws_list[[i]],drawsrep=drawsrep_list[[i]],draws_intra = draws_intra_list[[i]],drawsrepintra=drawsrepintra_list[[drawsrepintra_index[i]]],lengthinter = lengthinter_list[[i]],nrobs=nrobs_list[[i]],beta1=beta1,Ndraws=Ndraws,Nintradraws = Nintradraws,functionality = functionality,mixing=mixing,intramixing=intramixing)\n          \n        }else{\n          LL <-  herzstueck(customdata = data_list[[i]],draws = draws_list[[i]],drawsrep=drawsrep_list[[i]],lengthinter = lengthinter_list[[i]],nrobs=nrobs_list[[i]],beta1=beta1,Ndraws=Ndraws,functionality = functionality,mixing=mixing,intramixing=intramixing)\n          \n        }\n        \n        \n        #LL <-  herzstueck(customdata = customdata,draws = draws,drawsrep=drawsrep,draws_intra = draws_intra,drawsrepintra=drawsrepintra,lengthinter = lengthinter,nrobs=nrobs,beta1=beta1,Ndraws=Ndraws,Nintradraws = Nintradraws,functionality = functionality,mixing=mixing,intramixing=intramixing)\n        \n        \n        \n      } # %dopar%\n    \n    # done with parallel computing, transform owndata back\n    \n    #data_est <- rbindlist( data_outlist )\n    LL=unlist(data_outlist)\n    \n  } # %parallelcomputing==1%\n  \n  if (parallelcomputing==0) {\n    \n    \n    if(intramixing==1){\n      LL <-  herzstueck(customdata = owndata,draws = draws,drawsrep=drawsrep,draws_intra = draws_intra,drawsrepintra=drawsrepintra,lengthinter = lengthinter,nrobs=nrobs,beta1=beta1,Ndraws=Ndraws,Nintradraws = Nintradraws,functionality = functionality,mixing=mixing,intramixing=intramixing)\n      \n    }else{\n      LL <-  herzstueck(customdata = owndata,draws = draws,drawsrep=drawsrep,lengthinter = lengthinter,nrobs=nrobs,beta1=beta1,Ndraws=Ndraws,functionality = functionality,mixing=mixing,intramixing=intramixing)\n      \n    }\n    \n    \n  } # %parallelcomputing==0%\n  \n  \n  \n  \n  \n  #####################################################################\n  # subsection to produce output of function                          #\n  #####################################################################\n  \n  # remove beta names from memory so as to avoid double attachment of names in next iteration\n  print(paste0(\"Time Likelihood function: \",round(as.numeric(Sys.time()-start.time,units=\"secs\"),2)))\n  # return appropriate output\n  # if using estimate, return LL at beta\n  \n  \n  if (functionality==1)\n  {\n    print(sum(LL))\n    return(LL)\n  }\n  # if using apply, return predictions\n  else if (functionality==2)\n  {\n    return(probs_out)\n  }\n  # else return unconditional and conditional draws\n  else if (functionality==3)\n  {\n    return(draws_posteriors_out)\n  }\n  \n  \n  \n}\n\n#####################################################################\n#####################################################################\n# ESTIMATE THE MODEL                                                #\n#####################################################################\n#####################################################################\n\n\n# model estimation\nstart.overall.time<-Sys.time()\n\n#datareplicate <- rep(1:nrobs,each=Ndraws)[rep(1:lengthinter,each=Nintradraws)]\n\nrunmodel()#Availabilities\n\ntimetext <- paste0(\"Total MSL time =\",as.numeric(difftime(Sys.time(), start.overall.time,units = \"mins\")),\" mins\")\n\n\nwrite.csv(x= timetext,file = paste0(outputpath,\"MSLtime.csv\"))\n\n\nif(parallelcomputing==1){\n  finaldata =  rbindlist(data_list)\n}else{\n  finaldata = owndata\n}\n\n\n# formatted output (to screen)\nmodeloutput(model,finaldata)\n\n# write same output to file\nsaveoutput(model,finaldata,outputpath=outputpath)\n\n#####################################################################\n#####################################################################\n# GENERATE PREDICTIONS FROM THE MODEL                               #\n#####################################################################\n#####################################################################\n\nfunctionality=2\n\n# predictions are produced using the values in the vector beta\n# you may want to set this to the final estimates if you have just run a model\n# beta=model$est\n\npredictions=loglike(beta)\n\n# write.csv(predictions,paste(cbind(modelname,\"_predictions.csv\"),collapse=\"\"))\n\n\n\n#####################################################################\n#####################################################################\n# LIKELIHOOD RATIO TEST PROCEDURE                                   #\n#####################################################################\n#####################################################################\n\n# model fit for base model and general model, base model needs to restricted version of general model\nLL_base_model=\n  LL_general_model=\n  \n  # number of estimated parameters for both models\n  par_base_model=5\npar_general_model=7\n\n# working out LR test value and degrees of freedom\nLR_test_value=-2*(LL_base_model-LL_general_model)\ndf=par_general_model-par_base_model\n\n# p-value for LR test\npchisq(LR_test_value,df,lower.tail=FALSE)\n\n\n#------------------------------------\n\nprint(beta)\nstart.time<-Sys.time()\n\n# needed to be able to refer to parameters by name\nbeta1=as.list(beta)\n\ncustomdata<-owndata\n\n\ncustomdata1 <- as.matrix(customdata[,c(3,4,5,15,16,17,49)])\n",
    "created" : 1507034160813.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3544022533",
    "id" : "E1BE6D51",
    "lastKnownWriteTime" : 1506006117,
    "last_content_update" : 1506006117,
    "path" : "C:/Data/FMOD/MSL/scripts/Grapes/MSL_Ex_IE_onIELow_Grapes_500_verypars.R",
    "project_path" : null,
    "properties" : {
        "source_window_id" : "wt71uoahlzg6y"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}