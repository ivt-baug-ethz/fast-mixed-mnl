{
    "collab_server" : "",
    "contents" : "\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- PACKAGES -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\n# change local library if needed\n\nlocalLibrary <- NULL\n\nrequire(miscTools, lib.loc = localLibrary)\nrequire(zoo, lib.loc = localLibrary)\nrequire(maxLik, lib.loc = localLibrary)\nrequire(data.table, lib.loc = localLibrary)\nrequire(plyr, lib.loc = localLibrary)\nrequire(numDeriv, lib.loc = localLibrary)\nrequire(foreach, lib.loc = localLibrary)\nrequire(doParallel, lib.loc = localLibrary)\nrequire(sandwich, lib.loc = localLibrary)\nrequire(randtoolbox, lib.loc = localLibrary)\nrequire(dplyr, lib.loc = localLibrary)\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- CLEANING MEMORY AND LOADING FUNCTIONS -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\ndetachAllData <- function () {\n\n  pos.to.detach <- (1:length(search()))[substring(search(), first = 1, last = 8) != \"package:\" & \n                                          search() != \".GlobalEnv\" & search() != \"Autoloads\" & search() != \n                                          \"CheckExEnv\" & search() != \"tools:rstudio\" & search() != \"TempEnv\"]\nfor (i in 1:length(pos.to.detach)) {\n      \n  if (length(pos.to.detach) > 0) {\n  detach(pos = pos.to.detach[1])\n  pos.to.detach <- (1:length(search()))[substring(search(),\n  first = 1, last = 8) != \"package:\" & search() !=\n  \".GlobalEnv\" & search() != \"Autoloads\" & search() !=\n  \"CheckExEnv\" & search() != \"tools:rstudio\" &\n  search() != \"TempEnv\"]\n  \n    }\n  }\n}\n\ndetachAllData()\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- MODEL ESTIMATION -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\nrunmodel=function() {\n  \n  model<<-maxLik(loglike,start=beta,fixed=fixedparams,method=\"BFGS\",print.level=3,iterlim=10000)\n  loglikelihood_sum <- function(beta_est) sum(loglike(beta_est))\n  \n  message(\"hesse_start \",  Sys.time())\n  \n  model$hessian<<-numDeriv::hessian(func = loglikelihood_sum, x = model$estimate)\n  \n  message(\"hesse_end \",  Sys.time())\n  \n}\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- THE OUTSHEET FUNCTION -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\nmodeloutput=function(model) {\n  \n  if (functionality!=1) {\n    print(\"There is nothing to estimate!\")\n  }\n  \n  else {\n   est<<-model$estimate\n   varcov=vcov(model)\n   meat1=meat(model)\n   bread1=bread(model)\n   meat1[is.na(meat1)]=0\n   bread1[is.na(bread1)]=0\n   robvarcov<<-sandwich(model,bread1,meat1)\n   se=sqrt(diag(varcov))\n   robse=sqrt(diag(robvarcov))\n   trat_0=est/se\n   robtrat_0=est/robse\n   trat_1=(est-1)/se\n   robtrat_1=(est-1)/robse\n   se[model$fixed]=NA\n   robse[model$fixed]=NA\n   trat_0[model$fixed]=NA\n   robtrat_0[model$fixed]=NA\n   trat_1[model$fixed]=NA\n   robtrat_1[model$fixed]=NA\n   varcov[model$fixed,]=NA\n   varcov[,model$fixed]=NA\n   robvarcov[model$fixed,]<<-NA\n   robvarcov[,model$fixed]<<-NA\n   corrmat=varcov/(se%*%t(se))\n   robcorrmat=robvarcov/(robse%*%t(robse)) \n   iterations=model$iterations\n   zeroLL=sum(loglike(0*beta))\n   initLL=sum(loglike(beta))\n   finalLL=sum(loglike(est))\n   params=length(beta)-sum(model$fixed)\n   rho2zero=1-finalLL/zeroLL\n   adjrho2zero=1-(finalLL-params)/zeroLL\n   est=round(est,4)\n   se=round(se,4)\n   trat_0=round(trat_0,2)\n   trat_1=round(trat_1,2)\n   robse=round(robse,4)\n   robtrat_0=round(robtrat_0,2)\n   robtrat_1=round(robtrat_1,2)\n   output=t(rbind(est,se,trat_0,trat_1,robse,robtrat_0,robtrat_1))\n   \n   cat(\"Runtime:\", runtime,\"\\n\\n\")\n   cat(\"Model diagnosis:\",model$message,\"\\n\\n\")\n   cat(\"Number of decision makers:\",N,\"\\n\")\n   cat(\"Number of observations:\",choicetasks,\"\\n\\n\")\n   cat(\"Number of draws for random component:\",Ndraws,\"\\n\\n\")\n   \n   cat(\"LL(null): \",zeroLL,\"\\n\")\n   cat(\"LL(final): \",finalLL,\"\\n\")\n   cat(\"Rho2: \",rho2zero,\"\\n\")\n   \n   cat(\"Estimated parameters: \",length(beta)-length(fixedparams),\"\\n\\n\")\n  \n   cat(\"AIC: \",round(-2*finalLL+2*(length(beta)-length(fixedparams)),2),\"\\n\")\n   cat(\"AICc: \",round(-2*finalLL+2*(length(beta)-length(fixedparams))*N/(N-(length(beta)-length(fixedparams))-1),2),\"\\n\")\n   cat(\"BIC: \",round(-2*finalLL+(length(beta)-length(fixedparams))*log(choicetasks),2),\"\\n\\n\")\n   \n   cat(\"Estimates:\\n\")\n   print(output)\n  \n   varcov=signif(varcov,4)\n   robvarcov<<-signif(robvarcov,4)\n   \n  # cat(\"\\n\\nCovariance matrix:\\n\")\n  # print(varcov)\n  \n  # cat(\"\\n\\nCorrelation matrix:\\n\")\n  # print(corrmat)\n  \n  cat(\"\\n\\nRobust covariance matrix:\\n\")\n  print(robvarcov)\n  \n  # cat(\"\\n\\nRobust Correlation matrix:\\n\")\n  # print(robcorrmat)\n\n  }\n}\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- DRAW LIBRARY -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\nshuffle=function(inv){\nout=inv[rank(runif(length(inv)))];\nout}\n\n# MLHS\n\nmlhs=function(N,d,i){\ntemp=seq(0,N-1)/N;\nout=matrix(0,N*i,d);\nj=1;\nk=1;\nwhile(j<i+1){\nk=1;\nwhile(k<d+1){\nout[(1+N*(j-1)):(N*j),k]=shuffle(temp+runif(1)/N);\nk=k+1}\nj=j+1}\nout}\n\n# HALTON\n\nhalton=function(n,d){\nprime=2;\nout=(haltonsequence(prime,n));\ni=2;\nwhile(i<d+1){\nk=0\nwhile(k<1){\nprime=prime+1;\nif(sum(prime/1:prime==prime%/%1:prime)==2) k=1;\n}\n\nout=cbind(out,haltonsequence(prime,n));\ni=i+1}\nout}\n\nhaltonelement=function(prime,element){\nH=0;\npower=(1/prime);\nwhile(element>0){\ndigit=(element%%prime);\nH=H+digit*power;\nelement=element%/%prime;\npower=power/prime}\nH}\n\nhaltonsequence=function(prime,lengthvec){\ni=1;\nout=0;\nwhile(i<lengthvec+1){\nout[i]=haltonelement(prime,i);\ni=i+1}\nout}\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- ORDERED LOGIT -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\n# 4 items\n\nordered_logit_4=function(indic,lv,zeta,t1,t2,t3) {\n  prob=(    (exp(t1-zeta*lv)/(1 + exp(t1 - zeta*lv)))  * (indic == 1 )\n            + (exp(t2 - zeta*lv)/(1 + exp(t2 - zeta*lv)) - (exp(t1 - zeta*lv) / (1 + exp(t1 - zeta*lv)))) * (indic == 2 )\n            + (exp(t3 - zeta*lv)/(1 + exp(t3 - zeta*lv)) - (exp(t2 - zeta*lv) / (1 + exp(t2 - zeta*lv)))) * (indic == 3 )\n            + (1-exp(t3 - zeta*lv)/(1 + exp(t3 - zeta*lv))) * (indic == 4 ))\n  return(prob)\n}\n\n# 5 items\n\nordered_logit_5=function(indic,lv,zeta,t1,t2,t3,t4) {\n  prob=(    (exp(t1-zeta*lv)/(1 + exp(t1 - zeta*lv)))  * (indic == 1 )\n            + (exp(t2 - zeta*lv)/(1 + exp(t2 - zeta*lv)) - (exp(t1 - zeta*lv) / (1 + exp(t1 - zeta*lv)))) * (indic == 2 )\n            + (exp(t3 - zeta*lv)/(1 + exp(t3 - zeta*lv)) - (exp(t2 - zeta*lv) / (1 + exp(t2 - zeta*lv)))) * (indic == 3 )\n            + (exp(t4 - zeta*lv)/(1 + exp(t4 - zeta*lv)) - (exp(t3 - zeta*lv) / (1 + exp(t3 - zeta*lv)))) * (indic == 4 )\n            + (1-exp(t4 - zeta*lv)/(1 + exp(t4 - zeta*lv))) * (indic == 5 ))\n  return(prob)\n}\n\n# 7 items\n\nordered_logit_7=function(indic,lv,zeta,t1,t2,t3,t4,t5,t6) {\nprob=(    (exp(t1-zeta*lv)/(1 + exp(t1 - zeta*lv)))  * (indic == 1 )\n        + (exp(t2 - zeta*lv)/(1 + exp(t2 - zeta*lv)) - (exp(t1 - zeta*lv) / (1 + exp(t1 - zeta*lv)))) * (indic == 2 )\n        + (exp(t3 - zeta*lv)/(1 + exp(t3 - zeta*lv)) - (exp(t2 - zeta*lv) / (1 + exp(t2 - zeta*lv)))) * (indic == 3 )\n        + (exp(t4 - zeta*lv)/(1 + exp(t4 - zeta*lv)) - (exp(t3 - zeta*lv) / (1 + exp(t3 - zeta*lv)))) * (indic == 4 )\n        + (exp(t5 - zeta*lv)/(1 + exp(t5 - zeta*lv)) - (exp(t4 - zeta*lv) / (1 + exp(t4 - zeta*lv)))) * (indic == 5 )\n        + (exp(t6 - zeta*lv)/(1 + exp(t6 - zeta*lv)) - (exp(t5 - zeta*lv) / (1 + exp(t5 - zeta*lv)))) * (indic == 6 )\n        + (1-exp(t6 - zeta*lv)/(1 + exp(t6 - zeta*lv))) * (indic == 7 ))\nreturn(prob)\n}\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- DELTA METHOD -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\ndeltamethod=function(par1,par2)\n{\n  #\n  v1=est[par1]+est[par2]\n  se1=sqrt(robvarcov[par1,par1]+robvarcov[par2,par2]+2*robvarcov[par1,par2])\n  t1=round(v1/se1,2)\n  #\n  v2=est[par1]-est[par2]\n  se2=sqrt(robvarcov[par1,par1]+robvarcov[par2,par2]-2*robvarcov[par1,par2])\n  t2=round(v2/se2,2)\n  #\n  # v3=est[par2]-est[par1]\n  # se3=se2\n  # t3=-t2\n  #\n  v4=est[par1]/est[par2]*60\n  se4=sqrt(v4^2*(robvarcov[par1,par1]/(est[par1]^2)+robvarcov[par2,par2]/(est[par2]^2)-2*robvarcov[par1,par2]/(est[par1]*est[par2])))\n  t4=round(v4/se4,2)\n  #\n  # v5=est[par2]/est[par1]\n  # se5=sqrt(v5^2*(robvarcov[par1,par1]/(est[par1]^2)+robvarcov[par2,par2]/(est[par2]^2)-2*robvarcov[par1,par2]/(est[par1]*est[par2])))\n  # t5=round(v5/se5,2)\n  #\n  function_value=round(c(v1,v2,v4),4)\n  function_se=round(c(se1,se2,se4),4)\n  function_t=c(t1,t2,t4)\n  #\n  delta_output=cbind(function_value,function_se,function_t)\n  rownames(delta_output)=c(paste(cbind(par1,\"+\",par2),collapse=\"\"),paste(cbind(par1,\"-\",par2),collapse=\"\"),paste(cbind(par1,\"/\",par2),collapse=\"\"))\n  #\n  return(delta_output)\n}\n\nzweierdelta=function(par1,par2,par3)\n{\n  #\n  v1=est[par1]+est[par2]\n  var1=robvarcov[par1,par1] + robvarcov[par2,par2] +\n    2*robvarcov[par1,par2]\n  cov1 = robvarcov[par1,par3] + robvarcov[par2,par3]\n  \n  vtts = v1/est[par3]*60\n  se_vtts = sqrt(vtts^2*(var1/(v1^2)+robvarcov[par3,par3]/(est[par3]^2)-2*cov1/(v1*est[par3])))\n  t_vtts = round(vtts/se_vtts,2)\n  \n  #\n  function_value=round(c(vtts),4)\n  function_se=round(c(se_vtts),4)\n  function_t=c(t_vtts)\n  #\n  delta_output=cbind(function_value,function_se,function_t)\n  rownames(delta_output)=c(paste(cbind(par1,\" plus urban or purpose TT / \",par3),collapse=\"\"))\n  #\n  return(delta_output)\n}\n\n\nsuperdelta=function(par1,par2,par3,par4)\n{\n  #\n  v1=est[par1]+est[par2]+est[par3]\n  var1=robvarcov[par1,par1] + robvarcov[par2,par2] + robvarcov[par3,par3] +\n       2*robvarcov[par1,par2] + 2*robvarcov[par1,par3] + 2*robvarcov[par2,par3]  \n  cov1 = robvarcov[par1,par4] + robvarcov[par2,par4] + robvarcov[par3,par4]\n  \n  vtts = v1/est[par4]*60\n  se_vtts = sqrt(vtts^2*(var1/(v1^2)+robvarcov[par4,par4]/(est[par4]^2)-2*cov1/(v1*est[par4])))\n  t_vtts = round(vtts/se_vtts,2)\n    \n  #\n  function_value=round(c(vtts),4)\n  function_se=round(c(se_vtts),4)\n  function_t=c(t_vtts)\n  #\n  delta_output=cbind(function_value,function_se,function_t)\n  rownames(delta_output)=c(paste(cbind(par1,\" plus urban TT plus purpose TT / \",par4),collapse=\"\"))\n  #\n  return(delta_output)\n}\n\nmixldelta=function(par1,par2,par3)\n{\n  #\n  v1=est[par1]+est[par2]+est[par3]\n  var1=robvarcov[par1,par1] + robvarcov[par2,par2] + robvarcov[par3,par3] +\n    2*robvarcov[par1,par2] + 2*robvarcov[par1,par3] + 2*robvarcov[par2,par3]  \n  cov1 = robvarcov[par1,par4] + robvarcov[par2,par4] + robvarcov[par3,par4]\n  \n  vtts = v1/est[par4]*60\n  se_vtts = sqrt(vtts^2*(var1/(v1^2)+robvarcov[par4,par4]/(est[par4]^2)-2*cov1/(v1*est[par4])))\n  t_vtts = round(vtts/se_vtts,2)\n  \n  #\n  function_value=round(c(vtts),4)\n  function_se=round(c(se_vtts),4)\n  function_t=c(t_vtts)\n  #\n  delta_output=cbind(function_value,function_se,function_t)\n  rownames(delta_output)=c(paste(cbind(par1,\" plus urban TT plus purpose TT / \",par4),collapse=\"\"))\n  #\n  return(delta_output)\n}\n\n",
    "created" : 1507032717317.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3131437127",
    "id" : "20281EB7",
    "lastKnownWriteTime" : 1501592946,
    "last_content_update" : 1501592946,
    "path" : "P:/_TEMP/Molloy/2_MIXL_TRAIN/source_code.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}