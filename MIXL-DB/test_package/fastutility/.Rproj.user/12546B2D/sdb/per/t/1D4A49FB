{
    "collab_server" : "",
    "contents" : "# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- CLEANING MEMORY AND LOADING FUNCTIONS -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n#' @export\ndetachAllData <- function () {\n\n  pos.to.detach <- (1:length(search()))[substring(search(), first = 1, last = 8) != \"package:\" &\n                                          search() != \".GlobalEnv\" & search() != \"Autoloads\" & search() !=\n                                          \"CheckExEnv\" & search() != \"tools:rstudio\" & search() != \"TempEnv\"]\nfor (i in 1:length(pos.to.detach)) {\n\n  if (length(pos.to.detach) > 0) {\n  detach(pos = pos.to.detach[1])\n  pos.to.detach <- (1:length(search()))[substring(search(),\n  first = 1, last = 8) != \"package:\" & search() !=\n  \".GlobalEnv\" & search() != \"Autoloads\" & search() !=\n  \"CheckExEnv\" & search() != \"tools:rstudio\" &\n  search() != \"TempEnv\"]\n\n    }\n  }\n}\n\n#detachAllData()\n\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- MODEL ESTIMATION -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\n#return values per individual\n#' @export\nloglike=function(beta) {\n  return (foreach::foreach(i = 1:env$kernel, .combine='c' ) %dopar% {\n    individualLoglikelihood(env$data, env$Nindv,\n                            beta,\n                            env$draws, env$Ndraws, env$p)\n  })\n}\n\n#return only final LL value\n#' @export\nloglike_sum=function(beta) {\n  return (foreach::foreach(i = 1:env$kernel,  .combine='+' ) %dopar% {\n    loglikelihood(env$data, env$Nindv,\n                  beta,\n                  env$draws, env$Ndraws, env$p)\n  })\n}\n\n#' @export\nrunmodel=function(beta, fixedparams) {\n\n  model<-maxLik::maxLik(loglike,start=beta,fixed=fixedparams,method=\"BFGS\",print.level=3,iterlim=10000)\n\n  message(\"hesse_start \",  Sys.time())\n\n  model$hessian <- numDeriv::hessian(func = loglike_sum, x = model$estimate)\n\n  message(\"hesse_end \",  Sys.time())\n\n  return(model)\n\n}\n\n#execudes the model. Assumes that the data and draws are already prepared.\n# the data should be global as a dataframe, with individual id's starting at 1 to n\n# the draws must be a matrix of Nindividuals*Ndraws x Ndimensions.\n\n#' @export\nexecute=function(config, startvalues, fixedparams, data, N, draws, Ndraws) {\n  set.seed(config$seed)\n  env <<- new.env()\n\n\n  start <- Sys.time() ########## decide when to start\n  start\n  env$kernel <- config$number.of.cores\n  setUpCluster(env$kernel, data, N, draws, Ndraws)\n\n  env$model = runmodel(beta = startvalues, fixedparams = fixedparams)\n\n  env$runtime <- Sys.time() - start\n\n  runlabel <- paste0(modelname,\"_\", format(Sys.time(), \"%Y%m%d_%H%M%S_\"))\n\n  # formatted output\n  modeloutput(startvalues, env$model )\n\n  out <- capture.output(env$runtime, modeloutput(startvalues, env$model))\n  cat(out,file=paste0(runlabel, \"model.txt\"),sep=\"\\n\",append=TRUE)\n\n\n  # create latex-output (see also texout source code)\n\n  texout(startvalues, env$model)\n  save(est, file = paste0(modelname, \"_est.Rdata\"))\n  save(robvarcov, file = paste0(modelname, \"_robvarcov.Rdata\"))\n\n  #make sure we stop the cluster at the end\n  parallel::stopCluster(env$cl)\n\n  return (env$model)\n\n}\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- THE OUTSHEET FUNCTION -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\nmodeloutput=function(beta, model) {\n\n  if (functionality!=1) {\n    print(\"There is nothing to estimate!\")\n  }\n\n  else {\n   est<<-model$estimate\n   varcov=vcov(model)\n   meat1=sandwich::meat(model)\n   bread1=sandwich::bread(model)\n   meat1[is.na(meat1)]=0\n   bread1[is.na(bread1)]=0\n   robvarcov<-sandwich::sandwich(model,bread1,meat1)\n   se=sqrt(diag(varcov))\n   robse=sqrt(diag(robvarcov))\n   trat_0=est/se\n   robtrat_0=est/robse\n   trat_1=(est-1)/se\n   robtrat_1=(est-1)/robse\n   se[model$fixed]=NA\n   robse[model$fixed]=NA\n   trat_0[model$fixed]=NA\n   robtrat_0[model$fixed]=NA\n   trat_1[model$fixed]=NA\n   robtrat_1[model$fixed]=NA\n   varcov[model$fixed,]=NA\n   varcov[,model$fixed]=NA\n   robvarcov[model$fixed,]<-NA\n   robvarcov[,model$fixed]<-NA\n   corrmat=varcov/(se%*%t(se))\n   robcorrmat=robvarcov/(robse%*%t(robse))\n   iterations=model$iterations\n   zeroLL=sum(loglike(0*beta))\n   initLL=sum(loglike(beta))\n   finalLL=sum(loglike(est))\n   params=length(beta)-sum(model$fixed)\n   rho2zero=1-finalLL/zeroLL\n   adjrho2zero=1-(finalLL-params)/zeroLL\n   est=round(est,4)\n   se=round(se,4)\n   trat_0=round(trat_0,2)\n   trat_1=round(trat_1,2)\n   robse=round(robse,4)\n   robtrat_0=round(robtrat_0,2)\n   robtrat_1=round(robtrat_1,2)\n   output=t(rbind(est,se,trat_0,trat_1,robse,robtrat_0,robtrat_1))\n\n   cat(\"Runtime:\", env$runtime,\"\\n\\n\")\n   cat(\"Model diagnosis:\",model$message,\"\\n\\n\")\n   cat(\"Number of decision makers:\",N,\"\\n\")\n   cat(\"Number of observations:\",choicetasks,\"\\n\\n\")\n   cat(\"Number of draws for random component:\",Ndraws,\"\\n\\n\")\n\n   cat(\"LL(null): \",zeroLL,\"\\n\")\n   cat(\"LL(final): \",finalLL,\"\\n\")\n   cat(\"Rho2: \",rho2zero,\"\\n\")\n\n   cat(\"Estimated parameters: \",length(beta)-length(fixedparams),\"\\n\\n\")\n\n   cat(\"AIC: \",round(-2*finalLL+2*(length(beta)-length(fixedparams)),2),\"\\n\")\n   cat(\"AICc: \",round(-2*finalLL+2*(length(beta)-length(fixedparams))*N/(N-(length(beta)-length(fixedparams))-1),2),\"\\n\")\n   cat(\"BIC: \",round(-2*finalLL+(length(beta)-length(fixedparams))*log(choicetasks),2),\"\\n\\n\")\n\n   cat(\"Estimates:\\n\")\n   print(output)\n\n   varcov=signif(varcov,4)\n   robvarcov<<-signif(robvarcov,4)\n\n  # cat(\"\\n\\nCovariance matrix:\\n\")\n  # print(varcov)\n\n  # cat(\"\\n\\nCorrelation matrix:\\n\")\n  # print(corrmat)\n\n  cat(\"\\n\\nRobust covariance matrix:\\n\")\n  print(robvarcov)\n\n  # cat(\"\\n\\nRobust Correlation matrix:\\n\")\n  # print(robcorrmat)\n\n  }\n}\n\n\n# ------------------------------------------------------------------------------------------------------------#\n#\n# ------- DRAW LIBRARY -------\n#\n# ------------------------------------------------------------------------------------------------------------#\n\nshuffle=function(inv){\n  out=inv[rank(runif(length(inv)))];\n  out}\n\n# MLHS\n\nmlhs=function(N,d,i){\n  temp=seq(0,N-1)/N;\n  out=matrix(0,N*i,d);\n  j=1;\n  k=1;\n  while(j<i+1){\n    k=1;\n    while(k<d+1){\n      out[(1+N*(j-1)):(N*j),k]=shuffle(temp+runif(1)/N);\n      k=k+1}\n    j=j+1}\n  out}\n\n# HALTON\n\nhalton=function(n,d){\n  prime=2;\n  out=(haltonsequence(prime,n));\n  i=2;\n  while(i<d+1){\n    k=0\n    while(k<1){\n      prime=prime+1;\n      if(sum(prime/1:prime==prime%/%1:prime)==2) k=1;\n    }\n\n    out=cbind(out,haltonsequence(prime,n));\n    i=i+1}\n  out}\n\nhaltonelement=function(prime,element){\n  H=0;\n  power=(1/prime);\n  while(element>0){\n    digit=(element%%prime);\n    H=H+digit*power;\n    element=element%/%prime;\n    power=power/prime}\n  H}\n\nhaltonsequence=function(prime,lengthvec){\n  i=1;\n  out=0;\n  while(i<lengthvec+1){\n    out[i]=haltonelement(prime,i);\n    i=i+1}\n  out}\n\n\n\n",
    "created" : 1506519333100.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2630633884",
    "id" : "1D4A49FB",
    "lastKnownWriteTime" : 1507022746,
    "last_content_update" : 1507022746611,
    "path" : "P:/_TEMP/Molloy/2_MIXL_TRAIN/test_package/fastutility/R/source_code.R",
    "project_path" : "R/source_code.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}